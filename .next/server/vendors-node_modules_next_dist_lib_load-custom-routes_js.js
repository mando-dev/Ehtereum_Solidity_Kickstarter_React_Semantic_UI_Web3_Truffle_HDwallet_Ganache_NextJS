/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_next_dist_lib_load-custom-routes_js";
exports.ids = ["vendors-node_modules_next_dist_lib_load-custom-routes_js"];
exports.modules = {

/***/ "./node_modules/next/dist/compiled/escape-string-regexp/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/escape-string-regexp/index.js ***!
  \***********************************************************************/
/***/ (function(module) {

eval("module.exports=(()=>{\"use strict\";var e={813:e=>{const r=/[|\\\\{}()[\\]^$+*?.-]/g;e.exports=(e=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}return e.replace(r,\"\\\\$&\")})}};var r={};function __nccwpck_require__(t){if(r[t]){return r[t].exports}var _=r[t]={exports:{}};var a=true;try{e[t](_,_.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return _.exports}__nccwpck_require__.ab=__dirname+\"/\";return __nccwpck_require__(813)})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9raWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzPzU3YzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLGFBQWEsT0FBTyxRQUFRLGVBQWUsZ0JBQWdCLGVBQWUsd0JBQXdCLHlDQUF5QywyQkFBMkIsSUFBSSxTQUFTLGdDQUFnQyxTQUFTLG9CQUFvQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixxQ0FBcUMsZ0NBQWdDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs4MTM6ZT0+e2NvbnN0IHI9L1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZztlLmV4cG9ydHM9KGU9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1yZXR1cm4gZS5yZXBsYWNlKHIsXCJcXFxcJCZcIil9KX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7aWYoclt0XSl7cmV0dXJuIHJbdF0uZXhwb3J0c312YXIgXz1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKF8sXy5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBfLmV4cG9ydHN9X19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7cmV0dXJuIF9fbmNjd3Bja19yZXF1aXJlX18oODEzKX0pKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/escape-string-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9raWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzP2NjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUE4QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW9EO0FBQzdFO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBLG9FQUFvRSxVQUFVLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLG9FQUFvRSxVQUFVLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpREFBaUQsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyx3T0FBd08sVUFBVSxFQUFFO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQTZEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-to-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/lib/load-custom-routes.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/lib/load-custom-routes.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("exports.__esModule=true;exports.getRedirectStatus=getRedirectStatus;exports.normalizeRouteRegex=normalizeRouteRegex;exports.default=loadCustomRoutes;exports.allowedStatusCodes=void 0;var _url=__webpack_require__(/*! url */ \"url\");var pathToRegexp=_interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ \"./node_modules/next/dist/compiled/path-to-regexp/index.js\"));var _escapeStringRegexp=_interopRequireDefault(__webpack_require__(/*! next/dist/compiled/escape-string-regexp */ \"./node_modules/next/dist/compiled/escape-string-regexp/index.js\"));var _constants=__webpack_require__(/*! ../next-server/lib/constants */ \"../next-server/lib/constants\");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _getRequireWildcardCache(){if(typeof WeakMap!==\"function\")return null;var cache=new WeakMap();_getRequireWildcardCache=function(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}const allowedStatusCodes=new Set([301,302,303,307,308]);exports.allowedStatusCodes=allowedStatusCodes;const allowedHasTypes=new Set(['header','cookie','query','host']);const namedGroupsRegex=/\\(\\?<([a-zA-Z][a-zA-Z0-9]*)>/g;function getRedirectStatus(route){return route.statusCode||(route.permanent?_constants.PERMANENT_REDIRECT_STATUS:_constants.TEMPORARY_REDIRECT_STATUS);}function normalizeRouteRegex(regex){// clean up un-necessary escaping from regex.source which turns / into \\\\/\nreturn regex.replace(/\\\\\\//g,'/');}function checkRedirect(route){const invalidParts=[];let hadInvalidStatus=false;if(route.statusCode&&!allowedStatusCodes.has(route.statusCode)){hadInvalidStatus=true;invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`);}if(typeof route.permanent!=='boolean'&&!route.statusCode){invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``);}return{invalidParts,hadInvalidStatus};}function checkHeader(route){const invalidParts=[];if(!Array.isArray(route.headers)){invalidParts.push('`headers` field must be an array');}else{for(const header of route.headers){if(!header||typeof header!=='object'){invalidParts.push(\"`headers` items must be object with { key: '', value: '' }\");break;}if(typeof header.key!=='string'){invalidParts.push('`key` in header item must be string');break;}if(typeof header.value!=='string'){invalidParts.push('`value` in header item must be string');break;}}}return invalidParts;}function tryParsePath(route,handleUrl){const result={};let routePath=route;try{if(handleUrl){const parsedDestination=(0,_url.parse)(route,true);routePath=`${parsedDestination.pathname}${parsedDestination.hash||''}`;}// Make sure we can parse the source properly\nresult.tokens=pathToRegexp.parse(routePath);pathToRegexp.tokensToRegexp(result.tokens);}catch(err){// If there is an error show our error link but still show original error or a formatted one if we can\nconst errMatches=err.message.match(/at (\\d{0,})/);if(errMatches){const position=parseInt(errMatches[1],10);console.error(`\\nError parsing \\`${route}\\` `+`https://nextjs.org/docs/messages/invalid-route-source\\n`+`Reason: ${err.message}\\n\\n`+`  ${routePath}\\n`+`  ${new Array(position).fill(' ').join('')}^\\n`);}else{console.error(`\\nError parsing ${route} https://nextjs.org/docs/messages/invalid-route-source`,err);}result.error=true;}return result;}function checkCustomRoutes(routes,type){if(!Array.isArray(routes)){console.error(`Error: ${type}s must return an array, received ${typeof routes}.\\n`+`See here for more info: https://nextjs.org/docs/messages/routes-must-be-array`);process.exit(1);}let numInvalidRoutes=0;let hadInvalidStatus=false;let hadInvalidHas=false;const allowedKeys=new Set(['source','basePath','locale','has']);if(type==='rewrite'){allowedKeys.add('destination');}if(type==='redirect'){allowedKeys.add('statusCode');allowedKeys.add('permanent');allowedKeys.add('destination');}if(type==='header'){allowedKeys.add('headers');}for(const route of routes){if(!route||typeof route!=='object'){console.error(`The route ${JSON.stringify(route)} is not a valid object with \\`source\\` and \\`${type==='header'?'headers':'destination'}\\``);numInvalidRoutes++;continue;}if(type==='rewrite'&&route.basePath===false&&!(route.destination.startsWith('http://')||route.destination.startsWith('https://'))){console.error(`The route ${route.source} rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://nextjs.org/docs/messages/invalid-external-rewrite`);numInvalidRoutes++;continue;}const keys=Object.keys(route);const invalidKeys=keys.filter(key=>!allowedKeys.has(key));const invalidParts=[];if(typeof route.basePath!=='undefined'&&route.basePath!==false){invalidParts.push('`basePath` must be undefined or false');}if(typeof route.locale!=='undefined'&&route.locale!==false){invalidParts.push('`locale` must be undefined or false');}if(typeof route.has!=='undefined'&&!Array.isArray(route.has)){invalidParts.push('`has` must be undefined or valid has object');hadInvalidHas=true;}else if(route.has){const invalidHasItems=[];for(const hasItem of route.has){let invalidHasParts=[];if(!allowedHasTypes.has(hasItem.type)){invalidHasParts.push(`invalid type \"${hasItem.type}\"`);}if(typeof hasItem.key!=='string'&&hasItem.type!=='host'){invalidHasParts.push(`invalid key \"${hasItem.key}\"`);}if(typeof hasItem.value!=='undefined'&&typeof hasItem.value!=='string'){invalidHasParts.push(`invalid value \"${hasItem.value}\"`);}if(typeof hasItem.value==='undefined'&&hasItem.type==='host'){invalidHasParts.push(`value is required for \"host\" type`);}if(invalidHasParts.length>0){invalidHasItems.push(`${invalidHasParts.join(', ')} for ${JSON.stringify(hasItem)}`);}}if(invalidHasItems.length>0){hadInvalidHas=true;const itemStr=`item${invalidHasItems.length===1?'':'s'}`;console.error(`Invalid \\`has\\` ${itemStr}:\\n`+invalidHasItems.join('\\n'));console.error();invalidParts.push(`invalid \\`has\\` ${itemStr} found`);}}if(!route.source){invalidParts.push('`source` is missing');}else if(typeof route.source!=='string'){invalidParts.push('`source` is not a string');}else if(!route.source.startsWith('/')){invalidParts.push('`source` does not start with /');}if(type==='header'){invalidParts.push(...checkHeader(route));}else{let _route=route;if(!_route.destination){invalidParts.push('`destination` is missing');}else if(typeof _route.destination!=='string'){invalidParts.push('`destination` is not a string');}else if(type==='rewrite'&&!_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)){invalidParts.push('`destination` does not start with `/`, `http://`, or `https://`');}}if(type==='redirect'){const result=checkRedirect(route);hadInvalidStatus=hadInvalidStatus||result.hadInvalidStatus;invalidParts.push(...result.invalidParts);}let sourceTokens;if(typeof route.source==='string'&&route.source.startsWith('/')){// only show parse error if we didn't already show error\n// for not being a string\nconst{tokens,error}=tryParsePath(route.source);if(error){invalidParts.push('`source` parse failed');}sourceTokens=tokens;}const hasSegments=new Set();if(route.has){for(const hasItem of route.has){if(!hasItem.value&&hasItem.key){hasSegments.add(hasItem.key);}if(hasItem.value){for(const match of hasItem.value.matchAll(namedGroupsRegex)){if(match[1]){hasSegments.add(match[1]);}}if(hasItem.type==='host'){hasSegments.add('host');}}}}// make sure no unnamed patterns are attempted to be used in the\n// destination as this can cause confusion and is not allowed\nif(typeof route.destination==='string'){if(route.destination.startsWith('/')&&Array.isArray(sourceTokens)){const unnamedInDest=new Set();for(const token of sourceTokens){if(typeof token==='object'&&typeof token.name==='number'){const unnamedIndex=new RegExp(`:${token.name}(?!\\\\d)`);if(route.destination.match(unnamedIndex)){unnamedInDest.add(`:${token.name}`);}}}if(unnamedInDest.size>0){invalidParts.push(`\\`destination\\` has unnamed params ${[...unnamedInDest].join(', ')}`);}else{const{tokens:destTokens,error:destinationParseFailed}=tryParsePath(route.destination,true);if(destinationParseFailed){invalidParts.push('`destination` parse failed');}else{const sourceSegments=new Set(sourceTokens.map(item=>typeof item==='object'&&item.name).filter(Boolean));const invalidDestSegments=new Set();for(const token of destTokens){if(typeof token==='object'&&!sourceSegments.has(token.name)&&!hasSegments.has(token.name)){invalidDestSegments.add(token.name);}}if(invalidDestSegments.size){invalidParts.push(`\\`destination\\` has segments not in \\`source\\` or \\`has\\` (${[...invalidDestSegments].join(', ')})`);}}}}}const hasInvalidKeys=invalidKeys.length>0;const hasInvalidParts=invalidParts.length>0;if(hasInvalidKeys||hasInvalidParts){console.error(`${invalidParts.join(', ')}${invalidKeys.length?(hasInvalidParts?',':'')+` invalid field${invalidKeys.length===1?'':'s'}: `+invalidKeys.join(','):''} for route ${JSON.stringify(route)}`);console.error();numInvalidRoutes++;}}if(numInvalidRoutes>0){if(hadInvalidStatus){console.error(`\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(', ')}`);}if(hadInvalidHas){console.error(`\\nValid \\`has\\` object shape is ${JSON.stringify({type:[...allowedHasTypes].join(', '),key:'the key to check for',value:'undefined or a value string to match against'},null,2)}`);}console.error();console.error(`Error: Invalid ${type}${numInvalidRoutes===1?'':'s'} found`);process.exit(1);}}function processRoutes(routes,config,type){const _routes=routes;const newRoutes=[];const defaultLocales=[];if(config.i18n&&type==='redirect'){for(const item of((_config$i18n=config.i18n)==null?void 0:_config$i18n.domains)||[]){var _config$i18n;defaultLocales.push({locale:item.defaultLocale,base:`http${item.http?'':'s'}://${item.domain}`});}defaultLocales.push({locale:config.i18n.defaultLocale,base:''});}for(const r of _routes){var _r$destination;const srcBasePath=config.basePath&&r.basePath!==false?config.basePath:'';const isExternal=!((_r$destination=r.destination)!=null&&_r$destination.startsWith('/'));const destBasePath=srcBasePath&&!isExternal?srcBasePath:'';if(config.i18n&&r.locale!==false){var _r$destination2;defaultLocales.forEach(item=>{let destination;if(r.destination){destination=item.base?`${item.base}${destBasePath}${r.destination}`:`${destBasePath}${r.destination}`;}newRoutes.push({...r,destination,source:`${srcBasePath}/${item.locale}${r.source}`});});r.source=`/:nextInternalLocale(${config.i18n.locales.map(locale=>(0,_escapeStringRegexp.default)(locale)).join('|')})${r.source==='/'&&!config.trailingSlash?'':r.source}`;if(r.destination&&(_r$destination2=r.destination)!=null&&_r$destination2.startsWith('/')){r.destination=`/:nextInternalLocale${r.destination==='/'&&!config.trailingSlash?'':r.destination}`;}}r.source=`${srcBasePath}${r.source}`;if(r.destination){r.destination=`${destBasePath}${r.destination}`;}newRoutes.push(r);}return newRoutes;}async function loadRedirects(config){if(typeof config.redirects!=='function'){return[];}let redirects=await config.redirects();checkCustomRoutes(redirects,'redirect');return processRoutes(redirects,config,'redirect');}async function loadRewrites(config){if(typeof config.rewrites!=='function'){return{beforeFiles:[],afterFiles:[],fallback:[]};}const _rewrites=await config.rewrites();let beforeFiles=[];let afterFiles=[];let fallback=[];if(!Array.isArray(_rewrites)&&typeof _rewrites==='object'&&Object.keys(_rewrites).every(key=>key==='beforeFiles'||key==='afterFiles'||key==='fallback')){beforeFiles=_rewrites.beforeFiles||[];afterFiles=_rewrites.afterFiles||[];fallback=_rewrites.fallback||[];}else{afterFiles=_rewrites;}checkCustomRoutes(beforeFiles,'rewrite');checkCustomRoutes(afterFiles,'rewrite');checkCustomRoutes(fallback,'rewrite');return{beforeFiles:processRoutes(beforeFiles,config,'rewrite'),afterFiles:processRoutes(afterFiles,config,'rewrite'),fallback:processRoutes(fallback,config,'rewrite')};}async function loadHeaders(config){if(typeof config.headers!=='function'){return[];}let headers=await config.headers();checkCustomRoutes(headers,'header');return processRoutes(headers,config,'header');}async function loadCustomRoutes(config){const[headers,rewrites,redirects]=await Promise.all([loadHeaders(config),loadRewrites(config),loadRedirects(config)]);if(config.trailingSlash){redirects.unshift({source:'/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',destination:'/:file',permanent:true,locale:config.i18n?false:undefined,internal:true},{source:'/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',destination:'/:notfile/',permanent:true,locale:config.i18n?false:undefined,internal:true});if(config.basePath){redirects.unshift({source:config.basePath,destination:config.basePath+'/',permanent:true,basePath:false,locale:config.i18n?false:undefined,internal:true});}}else{redirects.unshift({source:'/:path+/',destination:'/:path+',permanent:true,locale:config.i18n?false:undefined,internal:true});if(config.basePath){redirects.unshift({source:config.basePath+'/',destination:config.basePath,permanent:true,basePath:false,locale:config.i18n?false:undefined,internal:true});}}return{headers,rewrites,redirects};}\n//# sourceMappingURL=load-custom-routes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9raWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMuanM/MTcwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSxrQkFBa0IsTUFBTSx5QkFBeUIsbUJBQW1CLDJCQUEyQixxQkFBcUIsZUFBZSxrQkFBa0IsMEJBQTBCLFFBQVEsU0FBUyxtQkFBTyxDQUFDLGdCQUFLLEVBQUUseUNBQXlDLG1CQUFPLENBQUMsb0dBQW1DLEdBQUcsK0NBQStDLG1CQUFPLENBQUMsZ0hBQXlDLEdBQUcsZUFBZSxtQkFBTyxDQUFDLGtFQUE4QixFQUFFLHFDQUFxQyxnQ0FBZ0MsY0FBYyxvQ0FBb0MsMkNBQTJDLHdCQUF3QixvQ0FBb0MsZUFBZSxjQUFjLHNDQUFzQyx3QkFBd0IsWUFBWSwrREFBK0QsT0FBTyxjQUFjLHFDQUFxQywwQkFBMEIsdUJBQXVCLGNBQWMsaUZBQWlGLG9CQUFvQixrREFBa0QsNkVBQTZFLCtCQUErQix3Q0FBd0MsS0FBSyx3QkFBd0IsbUJBQW1CLFVBQVUsdUJBQXVCLGVBQWUsd0RBQXdELDBCQUEwQixvQkFBb0Isa0VBQWtFLHVEQUF1RCxrQ0FBa0Msc0hBQXNILG9DQUFvQztBQUNodkQsbUNBQW1DLDhCQUE4QixzQkFBc0IsMkJBQTJCLGdFQUFnRSxzQkFBc0IsMEVBQTBFLDBEQUEwRCx3RUFBd0UsT0FBTyxnQ0FBZ0MsNEJBQTRCLHNCQUFzQixrQ0FBa0MsdURBQXVELEtBQUssbUNBQW1DLHNDQUFzQyx3REFBd0QscUJBQXFCLEdBQUcsT0FBTyxpQ0FBaUMseURBQXlELE9BQU8sbUNBQW1DLDJEQUEyRCxTQUFTLHFCQUFxQix1Q0FBdUMsZ0JBQWdCLG9CQUFvQixJQUFJLGNBQWMsbURBQW1ELGFBQWEsMkJBQTJCLEVBQUUsMkJBQTJCLEdBQUc7QUFDaHFDLDRDQUE0Qyw0Q0FBNEMsV0FBVztBQUNuRywyQ0FBMkMsR0FBRyxJQUFJLGVBQWUsMENBQTBDLG1DQUFtQyxNQUFNLDBFQUEwRSxZQUFZLFdBQVcsVUFBVSxTQUFTLHVDQUF1QyxPQUFPLEtBQUssaUNBQWlDLE1BQU0sOERBQThELG1CQUFtQixlQUFlLHdDQUF3QywyQkFBMkIsd0JBQXdCLEtBQUssbUNBQW1DLGNBQWMsc0ZBQXNGLGlCQUFpQix1QkFBdUIsMkJBQTJCLHdCQUF3QixnRUFBZ0UscUJBQXFCLGdDQUFnQyxzQkFBc0IsOEJBQThCLDZCQUE2QixnQ0FBZ0Msb0JBQW9CLDRCQUE0QiwyQkFBMkIsb0NBQW9DLDJCQUEyQixzQkFBc0IsK0NBQStDLHdDQUF3QyxLQUFLLG1CQUFtQixVQUFVLG1JQUFtSSwyQkFBMkIsYUFBYSwwS0FBMEssbUJBQW1CLFVBQVUsOEJBQThCLDBEQUEwRCxzQkFBc0IsZ0VBQWdFLDREQUE0RCw0REFBNEQsMERBQTBELDhEQUE4RCxpRUFBaUUsb0JBQW9CLG1CQUFtQix5QkFBeUIsZ0NBQWdDLHVCQUF1Qix1Q0FBdUMsc0NBQXNDLGFBQWEsS0FBSyx5REFBeUQscUNBQXFDLFlBQVksS0FBSyx3RUFBd0UsdUNBQXVDLGNBQWMsS0FBSyw4REFBOEQsMkRBQTJELDZCQUE2Qix3QkFBd0IsMkJBQTJCLE9BQU8sd0JBQXdCLEtBQUssNkJBQTZCLG1CQUFtQixxQkFBcUIsa0NBQWtDLEVBQUUsaUNBQWlDLFFBQVEsaUNBQWlDLGdCQUFnQixxQ0FBcUMsUUFBUSxXQUFXLGtCQUFrQiwwQ0FBMEMsd0NBQXdDLCtDQUErQyx1Q0FBdUMscURBQXFELG9CQUFvQiwwQ0FBMEMsS0FBSyxpQkFBaUIsd0JBQXdCLCtDQUErQyw4Q0FBOEMsb0RBQW9ELG1GQUFtRix1RkFBdUYsc0JBQXNCLGtDQUFrQywyREFBMkQsMkNBQTJDLGlCQUFpQixpRUFBaUU7QUFDejRIO0FBQ0EsTUFBTSxhQUFhLDRCQUE0QixVQUFVLDRDQUE0QyxxQkFBcUIsNEJBQTRCLGNBQWMsZ0NBQWdDLGdDQUFnQyw4QkFBOEIsa0JBQWtCLDZEQUE2RCxhQUFhLDRCQUE0QiwwQkFBMEIsNEJBQTRCO0FBQ2hiO0FBQ0Esd0NBQXdDLG1FQUFtRSw4QkFBOEIsaUNBQWlDLDBEQUEwRCxrQ0FBa0MsV0FBVyxVQUFVLDBDQUEwQyxzQkFBc0IsV0FBVyxNQUFNLHlCQUF5Qix3REFBd0QsOEJBQThCLElBQUksS0FBSyxNQUFNLCtDQUErQyxzQ0FBc0MsMkJBQTJCLGlEQUFpRCxLQUFLLHdHQUF3RyxvQ0FBb0MsK0JBQStCLDJGQUEyRixzQ0FBc0MsNkJBQTZCLGdGQUFnRixvQ0FBb0MsU0FBUywwQ0FBMEMsNENBQTRDLG9DQUFvQyxpQkFBaUIsd0JBQXdCLEVBQUUsNkRBQTZELDhCQUE4Qiw2QkFBNkIsYUFBYSxzQkFBc0IsR0FBRyxnQkFBZ0IscUJBQXFCLHVCQUF1QixxQkFBcUIsd0RBQXdELG1DQUFtQyxJQUFJLGtCQUFrQixpREFBaUQsZ0JBQWdCLHFIQUFxSCxTQUFTLElBQUksZ0JBQWdCLGdDQUFnQyxLQUFLLEVBQUUsNEJBQTRCLFNBQVMsa0JBQWtCLDJDQUEyQyxxQkFBcUIsbUJBQW1CLHdCQUF3QixtQ0FBbUMscUZBQXFGLGlCQUFpQixxQkFBcUIsc0NBQXNDLGlCQUFpQixLQUFLLFlBQVksRUFBRSxHQUFHLHFCQUFxQix5Q0FBeUMsR0FBRyx3QkFBd0IsbUJBQW1CLHlFQUF5RSx5RkFBeUYsMkRBQTJELGtDQUFrQyxvQkFBb0IsOEJBQThCLGdCQUFnQixrQkFBa0IseUJBQXlCLFVBQVUsRUFBRSxhQUFhLEVBQUUsY0FBYyxLQUFLLGFBQWEsRUFBRSxjQUFjLEdBQUcsZ0JBQWdCLDJCQUEyQixZQUFZLEdBQUcsWUFBWSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsaUNBQWlDLG1GQUFtRixHQUFHLGtEQUFrRCxFQUFFLDBGQUEwRixxQ0FBcUMsNERBQTRELElBQUksWUFBWSxZQUFZLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixpQkFBaUIsYUFBYSxFQUFFLGNBQWMsR0FBRyxtQkFBbUIsa0JBQWtCLHFDQUFxQyx5Q0FBeUMsVUFBVSx1Q0FBdUMsd0NBQXdDLG1EQUFtRCxvQ0FBb0Msd0NBQXdDLE9BQU8sMkNBQTJDLHdDQUF3QyxtQkFBbUIsa0JBQWtCLGdCQUFnQix5SkFBeUosc0NBQXNDLG9DQUFvQyxpQ0FBaUMsS0FBSyxzQkFBc0IseUNBQXlDLHdDQUF3QyxzQ0FBc0MsT0FBTyxrS0FBa0ssbUNBQW1DLHVDQUF1QyxVQUFVLG1DQUFtQyxvQ0FBb0MsK0NBQStDLHdDQUF3QyxzSEFBc0gseUJBQXlCLG1CQUFtQix3SkFBd0osRUFBRSwwSkFBMEosRUFBRSxvQkFBb0IsbUJBQW1CLHNJQUFzSSxJQUFJLEtBQUssbUJBQW1CLHdHQUF3RyxFQUFFLG9CQUFvQixtQkFBbUIsc0lBQXNJLElBQUksT0FBTztBQUNoZ0wiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmdldFJlZGlyZWN0U3RhdHVzPWdldFJlZGlyZWN0U3RhdHVzO2V4cG9ydHMubm9ybWFsaXplUm91dGVSZWdleD1ub3JtYWxpemVSb3V0ZVJlZ2V4O2V4cG9ydHMuZGVmYXVsdD1sb2FkQ3VzdG9tUm91dGVzO2V4cG9ydHMuYWxsb3dlZFN0YXR1c0NvZGVzPXZvaWQgMDt2YXIgX3VybD1yZXF1aXJlKFwidXJsXCIpO3ZhciBwYXRoVG9SZWdleHA9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cFwiKSk7dmFyIF9lc2NhcGVTdHJpbmdSZWdleHA9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2VzY2FwZS1zdHJpbmctcmVnZXhwXCIpKTt2YXIgX2NvbnN0YW50cz1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL2NvbnN0YW50c1wiKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian07fWZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpe2lmKHR5cGVvZiBXZWFrTWFwIT09XCJmdW5jdGlvblwiKXJldHVybiBudWxsO3ZhciBjYWNoZT1uZXcgV2Vha01hcCgpO19nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZT1mdW5jdGlvbigpe3JldHVybiBjYWNoZTt9O3JldHVybiBjYWNoZTt9ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKXtpZihvYmomJm9iai5fX2VzTW9kdWxlKXtyZXR1cm4gb2JqO31pZihvYmo9PT1udWxsfHx0eXBlb2Ygb2JqIT09XCJvYmplY3RcIiYmdHlwZW9mIG9iaiE9PVwiZnVuY3Rpb25cIil7cmV0dXJue2RlZmF1bHQ6b2JqfTt9dmFyIGNhY2hlPV9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO2lmKGNhY2hlJiZjYWNoZS5oYXMob2JqKSl7cmV0dXJuIGNhY2hlLmdldChvYmopO312YXIgbmV3T2JqPXt9O3ZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3I9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2Zvcih2YXIga2V5IGluIG9iail7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpKXt2YXIgZGVzYz1oYXNQcm9wZXJ0eURlc2NyaXB0b3I/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosa2V5KTpudWxsO2lmKGRlc2MmJihkZXNjLmdldHx8ZGVzYy5zZXQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLGtleSxkZXNjKTt9ZWxzZXtuZXdPYmpba2V5XT1vYmpba2V5XTt9fX1uZXdPYmouZGVmYXVsdD1vYmo7aWYoY2FjaGUpe2NhY2hlLnNldChvYmosbmV3T2JqKTt9cmV0dXJuIG5ld09iajt9Y29uc3QgYWxsb3dlZFN0YXR1c0NvZGVzPW5ldyBTZXQoWzMwMSwzMDIsMzAzLDMwNywzMDhdKTtleHBvcnRzLmFsbG93ZWRTdGF0dXNDb2Rlcz1hbGxvd2VkU3RhdHVzQ29kZXM7Y29uc3QgYWxsb3dlZEhhc1R5cGVzPW5ldyBTZXQoWydoZWFkZXInLCdjb29raWUnLCdxdWVyeScsJ2hvc3QnXSk7Y29uc3QgbmFtZWRHcm91cHNSZWdleD0vXFwoXFw/PChbYS16QS1aXVthLXpBLVowLTldKik+L2c7ZnVuY3Rpb24gZ2V0UmVkaXJlY3RTdGF0dXMocm91dGUpe3JldHVybiByb3V0ZS5zdGF0dXNDb2RlfHwocm91dGUucGVybWFuZW50P19jb25zdGFudHMuUEVSTUFORU5UX1JFRElSRUNUX1NUQVRVUzpfY29uc3RhbnRzLlRFTVBPUkFSWV9SRURJUkVDVF9TVEFUVVMpO31mdW5jdGlvbiBub3JtYWxpemVSb3V0ZVJlZ2V4KHJlZ2V4KXsvLyBjbGVhbiB1cCB1bi1uZWNlc3NhcnkgZXNjYXBpbmcgZnJvbSByZWdleC5zb3VyY2Ugd2hpY2ggdHVybnMgLyBpbnRvIFxcXFwvXG5yZXR1cm4gcmVnZXgucmVwbGFjZSgvXFxcXFxcLy9nLCcvJyk7fWZ1bmN0aW9uIGNoZWNrUmVkaXJlY3Qocm91dGUpe2NvbnN0IGludmFsaWRQYXJ0cz1bXTtsZXQgaGFkSW52YWxpZFN0YXR1cz1mYWxzZTtpZihyb3V0ZS5zdGF0dXNDb2RlJiYhYWxsb3dlZFN0YXR1c0NvZGVzLmhhcyhyb3V0ZS5zdGF0dXNDb2RlKSl7aGFkSW52YWxpZFN0YXR1cz10cnVlO2ludmFsaWRQYXJ0cy5wdXNoKGBcXGBzdGF0dXNDb2RlXFxgIGlzIG5vdCB1bmRlZmluZWQgb3IgdmFsaWQgc3RhdHVzQ29kZWApO31pZih0eXBlb2Ygcm91dGUucGVybWFuZW50IT09J2Jvb2xlYW4nJiYhcm91dGUuc3RhdHVzQ29kZSl7aW52YWxpZFBhcnRzLnB1c2goYFxcYHBlcm1hbmVudFxcYCBpcyBub3Qgc2V0IHRvIFxcYHRydWVcXGAgb3IgXFxgZmFsc2VcXGBgKTt9cmV0dXJue2ludmFsaWRQYXJ0cyxoYWRJbnZhbGlkU3RhdHVzfTt9ZnVuY3Rpb24gY2hlY2tIZWFkZXIocm91dGUpe2NvbnN0IGludmFsaWRQYXJ0cz1bXTtpZighQXJyYXkuaXNBcnJheShyb3V0ZS5oZWFkZXJzKSl7aW52YWxpZFBhcnRzLnB1c2goJ2BoZWFkZXJzYCBmaWVsZCBtdXN0IGJlIGFuIGFycmF5Jyk7fWVsc2V7Zm9yKGNvbnN0IGhlYWRlciBvZiByb3V0ZS5oZWFkZXJzKXtpZighaGVhZGVyfHx0eXBlb2YgaGVhZGVyIT09J29iamVjdCcpe2ludmFsaWRQYXJ0cy5wdXNoKFwiYGhlYWRlcnNgIGl0ZW1zIG11c3QgYmUgb2JqZWN0IHdpdGggeyBrZXk6ICcnLCB2YWx1ZTogJycgfVwiKTticmVhazt9aWYodHlwZW9mIGhlYWRlci5rZXkhPT0nc3RyaW5nJyl7aW52YWxpZFBhcnRzLnB1c2goJ2BrZXlgIGluIGhlYWRlciBpdGVtIG11c3QgYmUgc3RyaW5nJyk7YnJlYWs7fWlmKHR5cGVvZiBoZWFkZXIudmFsdWUhPT0nc3RyaW5nJyl7aW52YWxpZFBhcnRzLnB1c2goJ2B2YWx1ZWAgaW4gaGVhZGVyIGl0ZW0gbXVzdCBiZSBzdHJpbmcnKTticmVhazt9fX1yZXR1cm4gaW52YWxpZFBhcnRzO31mdW5jdGlvbiB0cnlQYXJzZVBhdGgocm91dGUsaGFuZGxlVXJsKXtjb25zdCByZXN1bHQ9e307bGV0IHJvdXRlUGF0aD1yb3V0ZTt0cnl7aWYoaGFuZGxlVXJsKXtjb25zdCBwYXJzZWREZXN0aW5hdGlvbj0oMCxfdXJsLnBhcnNlKShyb3V0ZSx0cnVlKTtyb3V0ZVBhdGg9YCR7cGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWV9JHtwYXJzZWREZXN0aW5hdGlvbi5oYXNofHwnJ31gO30vLyBNYWtlIHN1cmUgd2UgY2FuIHBhcnNlIHRoZSBzb3VyY2UgcHJvcGVybHlcbnJlc3VsdC50b2tlbnM9cGF0aFRvUmVnZXhwLnBhcnNlKHJvdXRlUGF0aCk7cGF0aFRvUmVnZXhwLnRva2Vuc1RvUmVnZXhwKHJlc3VsdC50b2tlbnMpO31jYXRjaChlcnIpey8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHNob3cgb3VyIGVycm9yIGxpbmsgYnV0IHN0aWxsIHNob3cgb3JpZ2luYWwgZXJyb3Igb3IgYSBmb3JtYXR0ZWQgb25lIGlmIHdlIGNhblxuY29uc3QgZXJyTWF0Y2hlcz1lcnIubWVzc2FnZS5tYXRjaCgvYXQgKFxcZHswLH0pLyk7aWYoZXJyTWF0Y2hlcyl7Y29uc3QgcG9zaXRpb249cGFyc2VJbnQoZXJyTWF0Y2hlc1sxXSwxMCk7Y29uc29sZS5lcnJvcihgXFxuRXJyb3IgcGFyc2luZyBcXGAke3JvdXRlfVxcYCBgK2BodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJvdXRlLXNvdXJjZVxcbmArYFJlYXNvbjogJHtlcnIubWVzc2FnZX1cXG5cXG5gK2AgICR7cm91dGVQYXRofVxcbmArYCAgJHtuZXcgQXJyYXkocG9zaXRpb24pLmZpbGwoJyAnKS5qb2luKCcnKX1eXFxuYCk7fWVsc2V7Y29uc29sZS5lcnJvcihgXFxuRXJyb3IgcGFyc2luZyAke3JvdXRlfSBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJvdXRlLXNvdXJjZWAsZXJyKTt9cmVzdWx0LmVycm9yPXRydWU7fXJldHVybiByZXN1bHQ7fWZ1bmN0aW9uIGNoZWNrQ3VzdG9tUm91dGVzKHJvdXRlcyx0eXBlKXtpZighQXJyYXkuaXNBcnJheShyb3V0ZXMpKXtjb25zb2xlLmVycm9yKGBFcnJvcjogJHt0eXBlfXMgbXVzdCByZXR1cm4gYW4gYXJyYXksIHJlY2VpdmVkICR7dHlwZW9mIHJvdXRlc30uXFxuYCtgU2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcm91dGVzLW11c3QtYmUtYXJyYXlgKTtwcm9jZXNzLmV4aXQoMSk7fWxldCBudW1JbnZhbGlkUm91dGVzPTA7bGV0IGhhZEludmFsaWRTdGF0dXM9ZmFsc2U7bGV0IGhhZEludmFsaWRIYXM9ZmFsc2U7Y29uc3QgYWxsb3dlZEtleXM9bmV3IFNldChbJ3NvdXJjZScsJ2Jhc2VQYXRoJywnbG9jYWxlJywnaGFzJ10pO2lmKHR5cGU9PT0ncmV3cml0ZScpe2FsbG93ZWRLZXlzLmFkZCgnZGVzdGluYXRpb24nKTt9aWYodHlwZT09PSdyZWRpcmVjdCcpe2FsbG93ZWRLZXlzLmFkZCgnc3RhdHVzQ29kZScpO2FsbG93ZWRLZXlzLmFkZCgncGVybWFuZW50Jyk7YWxsb3dlZEtleXMuYWRkKCdkZXN0aW5hdGlvbicpO31pZih0eXBlPT09J2hlYWRlcicpe2FsbG93ZWRLZXlzLmFkZCgnaGVhZGVycycpO31mb3IoY29uc3Qgcm91dGUgb2Ygcm91dGVzKXtpZighcm91dGV8fHR5cGVvZiByb3V0ZSE9PSdvYmplY3QnKXtjb25zb2xlLmVycm9yKGBUaGUgcm91dGUgJHtKU09OLnN0cmluZ2lmeShyb3V0ZSl9IGlzIG5vdCBhIHZhbGlkIG9iamVjdCB3aXRoIFxcYHNvdXJjZVxcYCBhbmQgXFxgJHt0eXBlPT09J2hlYWRlcic/J2hlYWRlcnMnOidkZXN0aW5hdGlvbid9XFxgYCk7bnVtSW52YWxpZFJvdXRlcysrO2NvbnRpbnVlO31pZih0eXBlPT09J3Jld3JpdGUnJiZyb3V0ZS5iYXNlUGF0aD09PWZhbHNlJiYhKHJvdXRlLmRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKXx8cm91dGUuZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkpe2NvbnNvbGUuZXJyb3IoYFRoZSByb3V0ZSAke3JvdXRlLnNvdXJjZX0gcmV3cml0ZXMgdXJscyBvdXRzaWRlIG9mIHRoZSBiYXNlUGF0aC4gUGxlYXNlIHVzZSBhIGRlc3RpbmF0aW9uIHRoYXQgc3RhcnRzIHdpdGggXFxgaHR0cDovL1xcYCBvciBcXGBodHRwczovL1xcYCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLWV4dGVybmFsLXJld3JpdGVgKTtudW1JbnZhbGlkUm91dGVzKys7Y29udGludWU7fWNvbnN0IGtleXM9T2JqZWN0LmtleXMocm91dGUpO2NvbnN0IGludmFsaWRLZXlzPWtleXMuZmlsdGVyKGtleT0+IWFsbG93ZWRLZXlzLmhhcyhrZXkpKTtjb25zdCBpbnZhbGlkUGFydHM9W107aWYodHlwZW9mIHJvdXRlLmJhc2VQYXRoIT09J3VuZGVmaW5lZCcmJnJvdXRlLmJhc2VQYXRoIT09ZmFsc2Upe2ludmFsaWRQYXJ0cy5wdXNoKCdgYmFzZVBhdGhgIG11c3QgYmUgdW5kZWZpbmVkIG9yIGZhbHNlJyk7fWlmKHR5cGVvZiByb3V0ZS5sb2NhbGUhPT0ndW5kZWZpbmVkJyYmcm91dGUubG9jYWxlIT09ZmFsc2Upe2ludmFsaWRQYXJ0cy5wdXNoKCdgbG9jYWxlYCBtdXN0IGJlIHVuZGVmaW5lZCBvciBmYWxzZScpO31pZih0eXBlb2Ygcm91dGUuaGFzIT09J3VuZGVmaW5lZCcmJiFBcnJheS5pc0FycmF5KHJvdXRlLmhhcykpe2ludmFsaWRQYXJ0cy5wdXNoKCdgaGFzYCBtdXN0IGJlIHVuZGVmaW5lZCBvciB2YWxpZCBoYXMgb2JqZWN0Jyk7aGFkSW52YWxpZEhhcz10cnVlO31lbHNlIGlmKHJvdXRlLmhhcyl7Y29uc3QgaW52YWxpZEhhc0l0ZW1zPVtdO2Zvcihjb25zdCBoYXNJdGVtIG9mIHJvdXRlLmhhcyl7bGV0IGludmFsaWRIYXNQYXJ0cz1bXTtpZighYWxsb3dlZEhhc1R5cGVzLmhhcyhoYXNJdGVtLnR5cGUpKXtpbnZhbGlkSGFzUGFydHMucHVzaChgaW52YWxpZCB0eXBlIFwiJHtoYXNJdGVtLnR5cGV9XCJgKTt9aWYodHlwZW9mIGhhc0l0ZW0ua2V5IT09J3N0cmluZycmJmhhc0l0ZW0udHlwZSE9PSdob3N0Jyl7aW52YWxpZEhhc1BhcnRzLnB1c2goYGludmFsaWQga2V5IFwiJHtoYXNJdGVtLmtleX1cImApO31pZih0eXBlb2YgaGFzSXRlbS52YWx1ZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgaGFzSXRlbS52YWx1ZSE9PSdzdHJpbmcnKXtpbnZhbGlkSGFzUGFydHMucHVzaChgaW52YWxpZCB2YWx1ZSBcIiR7aGFzSXRlbS52YWx1ZX1cImApO31pZih0eXBlb2YgaGFzSXRlbS52YWx1ZT09PSd1bmRlZmluZWQnJiZoYXNJdGVtLnR5cGU9PT0naG9zdCcpe2ludmFsaWRIYXNQYXJ0cy5wdXNoKGB2YWx1ZSBpcyByZXF1aXJlZCBmb3IgXCJob3N0XCIgdHlwZWApO31pZihpbnZhbGlkSGFzUGFydHMubGVuZ3RoPjApe2ludmFsaWRIYXNJdGVtcy5wdXNoKGAke2ludmFsaWRIYXNQYXJ0cy5qb2luKCcsICcpfSBmb3IgJHtKU09OLnN0cmluZ2lmeShoYXNJdGVtKX1gKTt9fWlmKGludmFsaWRIYXNJdGVtcy5sZW5ndGg+MCl7aGFkSW52YWxpZEhhcz10cnVlO2NvbnN0IGl0ZW1TdHI9YGl0ZW0ke2ludmFsaWRIYXNJdGVtcy5sZW5ndGg9PT0xPycnOidzJ31gO2NvbnNvbGUuZXJyb3IoYEludmFsaWQgXFxgaGFzXFxgICR7aXRlbVN0cn06XFxuYCtpbnZhbGlkSGFzSXRlbXMuam9pbignXFxuJykpO2NvbnNvbGUuZXJyb3IoKTtpbnZhbGlkUGFydHMucHVzaChgaW52YWxpZCBcXGBoYXNcXGAgJHtpdGVtU3RyfSBmb3VuZGApO319aWYoIXJvdXRlLnNvdXJjZSl7aW52YWxpZFBhcnRzLnB1c2goJ2Bzb3VyY2VgIGlzIG1pc3NpbmcnKTt9ZWxzZSBpZih0eXBlb2Ygcm91dGUuc291cmNlIT09J3N0cmluZycpe2ludmFsaWRQYXJ0cy5wdXNoKCdgc291cmNlYCBpcyBub3QgYSBzdHJpbmcnKTt9ZWxzZSBpZighcm91dGUuc291cmNlLnN0YXJ0c1dpdGgoJy8nKSl7aW52YWxpZFBhcnRzLnB1c2goJ2Bzb3VyY2VgIGRvZXMgbm90IHN0YXJ0IHdpdGggLycpO31pZih0eXBlPT09J2hlYWRlcicpe2ludmFsaWRQYXJ0cy5wdXNoKC4uLmNoZWNrSGVhZGVyKHJvdXRlKSk7fWVsc2V7bGV0IF9yb3V0ZT1yb3V0ZTtpZighX3JvdXRlLmRlc3RpbmF0aW9uKXtpbnZhbGlkUGFydHMucHVzaCgnYGRlc3RpbmF0aW9uYCBpcyBtaXNzaW5nJyk7fWVsc2UgaWYodHlwZW9mIF9yb3V0ZS5kZXN0aW5hdGlvbiE9PSdzdHJpbmcnKXtpbnZhbGlkUGFydHMucHVzaCgnYGRlc3RpbmF0aW9uYCBpcyBub3QgYSBzdHJpbmcnKTt9ZWxzZSBpZih0eXBlPT09J3Jld3JpdGUnJiYhX3JvdXRlLmRlc3RpbmF0aW9uLm1hdGNoKC9eKFxcL3xodHRwczpcXC9cXC98aHR0cDpcXC9cXC8pLykpe2ludmFsaWRQYXJ0cy5wdXNoKCdgZGVzdGluYXRpb25gIGRvZXMgbm90IHN0YXJ0IHdpdGggYC9gLCBgaHR0cDovL2AsIG9yIGBodHRwczovL2AnKTt9fWlmKHR5cGU9PT0ncmVkaXJlY3QnKXtjb25zdCByZXN1bHQ9Y2hlY2tSZWRpcmVjdChyb3V0ZSk7aGFkSW52YWxpZFN0YXR1cz1oYWRJbnZhbGlkU3RhdHVzfHxyZXN1bHQuaGFkSW52YWxpZFN0YXR1cztpbnZhbGlkUGFydHMucHVzaCguLi5yZXN1bHQuaW52YWxpZFBhcnRzKTt9bGV0IHNvdXJjZVRva2VucztpZih0eXBlb2Ygcm91dGUuc291cmNlPT09J3N0cmluZycmJnJvdXRlLnNvdXJjZS5zdGFydHNXaXRoKCcvJykpey8vIG9ubHkgc2hvdyBwYXJzZSBlcnJvciBpZiB3ZSBkaWRuJ3QgYWxyZWFkeSBzaG93IGVycm9yXG4vLyBmb3Igbm90IGJlaW5nIGEgc3RyaW5nXG5jb25zdHt0b2tlbnMsZXJyb3J9PXRyeVBhcnNlUGF0aChyb3V0ZS5zb3VyY2UpO2lmKGVycm9yKXtpbnZhbGlkUGFydHMucHVzaCgnYHNvdXJjZWAgcGFyc2UgZmFpbGVkJyk7fXNvdXJjZVRva2Vucz10b2tlbnM7fWNvbnN0IGhhc1NlZ21lbnRzPW5ldyBTZXQoKTtpZihyb3V0ZS5oYXMpe2Zvcihjb25zdCBoYXNJdGVtIG9mIHJvdXRlLmhhcyl7aWYoIWhhc0l0ZW0udmFsdWUmJmhhc0l0ZW0ua2V5KXtoYXNTZWdtZW50cy5hZGQoaGFzSXRlbS5rZXkpO31pZihoYXNJdGVtLnZhbHVlKXtmb3IoY29uc3QgbWF0Y2ggb2YgaGFzSXRlbS52YWx1ZS5tYXRjaEFsbChuYW1lZEdyb3Vwc1JlZ2V4KSl7aWYobWF0Y2hbMV0pe2hhc1NlZ21lbnRzLmFkZChtYXRjaFsxXSk7fX1pZihoYXNJdGVtLnR5cGU9PT0naG9zdCcpe2hhc1NlZ21lbnRzLmFkZCgnaG9zdCcpO319fX0vLyBtYWtlIHN1cmUgbm8gdW5uYW1lZCBwYXR0ZXJucyBhcmUgYXR0ZW1wdGVkIHRvIGJlIHVzZWQgaW4gdGhlXG4vLyBkZXN0aW5hdGlvbiBhcyB0aGlzIGNhbiBjYXVzZSBjb25mdXNpb24gYW5kIGlzIG5vdCBhbGxvd2VkXG5pZih0eXBlb2Ygcm91dGUuZGVzdGluYXRpb249PT0nc3RyaW5nJyl7aWYocm91dGUuZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpJiZBcnJheS5pc0FycmF5KHNvdXJjZVRva2Vucykpe2NvbnN0IHVubmFtZWRJbkRlc3Q9bmV3IFNldCgpO2Zvcihjb25zdCB0b2tlbiBvZiBzb3VyY2VUb2tlbnMpe2lmKHR5cGVvZiB0b2tlbj09PSdvYmplY3QnJiZ0eXBlb2YgdG9rZW4ubmFtZT09PSdudW1iZXInKXtjb25zdCB1bm5hbWVkSW5kZXg9bmV3IFJlZ0V4cChgOiR7dG9rZW4ubmFtZX0oPyFcXFxcZClgKTtpZihyb3V0ZS5kZXN0aW5hdGlvbi5tYXRjaCh1bm5hbWVkSW5kZXgpKXt1bm5hbWVkSW5EZXN0LmFkZChgOiR7dG9rZW4ubmFtZX1gKTt9fX1pZih1bm5hbWVkSW5EZXN0LnNpemU+MCl7aW52YWxpZFBhcnRzLnB1c2goYFxcYGRlc3RpbmF0aW9uXFxgIGhhcyB1bm5hbWVkIHBhcmFtcyAke1suLi51bm5hbWVkSW5EZXN0XS5qb2luKCcsICcpfWApO31lbHNle2NvbnN0e3Rva2VuczpkZXN0VG9rZW5zLGVycm9yOmRlc3RpbmF0aW9uUGFyc2VGYWlsZWR9PXRyeVBhcnNlUGF0aChyb3V0ZS5kZXN0aW5hdGlvbix0cnVlKTtpZihkZXN0aW5hdGlvblBhcnNlRmFpbGVkKXtpbnZhbGlkUGFydHMucHVzaCgnYGRlc3RpbmF0aW9uYCBwYXJzZSBmYWlsZWQnKTt9ZWxzZXtjb25zdCBzb3VyY2VTZWdtZW50cz1uZXcgU2V0KHNvdXJjZVRva2Vucy5tYXAoaXRlbT0+dHlwZW9mIGl0ZW09PT0nb2JqZWN0JyYmaXRlbS5uYW1lKS5maWx0ZXIoQm9vbGVhbikpO2NvbnN0IGludmFsaWREZXN0U2VnbWVudHM9bmV3IFNldCgpO2Zvcihjb25zdCB0b2tlbiBvZiBkZXN0VG9rZW5zKXtpZih0eXBlb2YgdG9rZW49PT0nb2JqZWN0JyYmIXNvdXJjZVNlZ21lbnRzLmhhcyh0b2tlbi5uYW1lKSYmIWhhc1NlZ21lbnRzLmhhcyh0b2tlbi5uYW1lKSl7aW52YWxpZERlc3RTZWdtZW50cy5hZGQodG9rZW4ubmFtZSk7fX1pZihpbnZhbGlkRGVzdFNlZ21lbnRzLnNpemUpe2ludmFsaWRQYXJ0cy5wdXNoKGBcXGBkZXN0aW5hdGlvblxcYCBoYXMgc2VnbWVudHMgbm90IGluIFxcYHNvdXJjZVxcYCBvciBcXGBoYXNcXGAgKCR7Wy4uLmludmFsaWREZXN0U2VnbWVudHNdLmpvaW4oJywgJyl9KWApO319fX19Y29uc3QgaGFzSW52YWxpZEtleXM9aW52YWxpZEtleXMubGVuZ3RoPjA7Y29uc3QgaGFzSW52YWxpZFBhcnRzPWludmFsaWRQYXJ0cy5sZW5ndGg+MDtpZihoYXNJbnZhbGlkS2V5c3x8aGFzSW52YWxpZFBhcnRzKXtjb25zb2xlLmVycm9yKGAke2ludmFsaWRQYXJ0cy5qb2luKCcsICcpfSR7aW52YWxpZEtleXMubGVuZ3RoPyhoYXNJbnZhbGlkUGFydHM/JywnOicnKStgIGludmFsaWQgZmllbGQke2ludmFsaWRLZXlzLmxlbmd0aD09PTE/Jyc6J3MnfTogYCtpbnZhbGlkS2V5cy5qb2luKCcsJyk6Jyd9IGZvciByb3V0ZSAke0pTT04uc3RyaW5naWZ5KHJvdXRlKX1gKTtjb25zb2xlLmVycm9yKCk7bnVtSW52YWxpZFJvdXRlcysrO319aWYobnVtSW52YWxpZFJvdXRlcz4wKXtpZihoYWRJbnZhbGlkU3RhdHVzKXtjb25zb2xlLmVycm9yKGBcXG5WYWxpZCByZWRpcmVjdCBzdGF0dXNDb2RlIHZhbHVlcyBhcmUgJHtbLi4uYWxsb3dlZFN0YXR1c0NvZGVzXS5qb2luKCcsICcpfWApO31pZihoYWRJbnZhbGlkSGFzKXtjb25zb2xlLmVycm9yKGBcXG5WYWxpZCBcXGBoYXNcXGAgb2JqZWN0IHNoYXBlIGlzICR7SlNPTi5zdHJpbmdpZnkoe3R5cGU6Wy4uLmFsbG93ZWRIYXNUeXBlc10uam9pbignLCAnKSxrZXk6J3RoZSBrZXkgdG8gY2hlY2sgZm9yJyx2YWx1ZTondW5kZWZpbmVkIG9yIGEgdmFsdWUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QnfSxudWxsLDIpfWApO31jb25zb2xlLmVycm9yKCk7Y29uc29sZS5lcnJvcihgRXJyb3I6IEludmFsaWQgJHt0eXBlfSR7bnVtSW52YWxpZFJvdXRlcz09PTE/Jyc6J3MnfSBmb3VuZGApO3Byb2Nlc3MuZXhpdCgxKTt9fWZ1bmN0aW9uIHByb2Nlc3NSb3V0ZXMocm91dGVzLGNvbmZpZyx0eXBlKXtjb25zdCBfcm91dGVzPXJvdXRlcztjb25zdCBuZXdSb3V0ZXM9W107Y29uc3QgZGVmYXVsdExvY2FsZXM9W107aWYoY29uZmlnLmkxOG4mJnR5cGU9PT0ncmVkaXJlY3QnKXtmb3IoY29uc3QgaXRlbSBvZigoX2NvbmZpZyRpMThuPWNvbmZpZy5pMThuKT09bnVsbD92b2lkIDA6X2NvbmZpZyRpMThuLmRvbWFpbnMpfHxbXSl7dmFyIF9jb25maWckaTE4bjtkZWZhdWx0TG9jYWxlcy5wdXNoKHtsb2NhbGU6aXRlbS5kZWZhdWx0TG9jYWxlLGJhc2U6YGh0dHAke2l0ZW0uaHR0cD8nJzoncyd9Oi8vJHtpdGVtLmRvbWFpbn1gfSk7fWRlZmF1bHRMb2NhbGVzLnB1c2goe2xvY2FsZTpjb25maWcuaTE4bi5kZWZhdWx0TG9jYWxlLGJhc2U6Jyd9KTt9Zm9yKGNvbnN0IHIgb2YgX3JvdXRlcyl7dmFyIF9yJGRlc3RpbmF0aW9uO2NvbnN0IHNyY0Jhc2VQYXRoPWNvbmZpZy5iYXNlUGF0aCYmci5iYXNlUGF0aCE9PWZhbHNlP2NvbmZpZy5iYXNlUGF0aDonJztjb25zdCBpc0V4dGVybmFsPSEoKF9yJGRlc3RpbmF0aW9uPXIuZGVzdGluYXRpb24pIT1udWxsJiZfciRkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpO2NvbnN0IGRlc3RCYXNlUGF0aD1zcmNCYXNlUGF0aCYmIWlzRXh0ZXJuYWw/c3JjQmFzZVBhdGg6Jyc7aWYoY29uZmlnLmkxOG4mJnIubG9jYWxlIT09ZmFsc2Upe3ZhciBfciRkZXN0aW5hdGlvbjI7ZGVmYXVsdExvY2FsZXMuZm9yRWFjaChpdGVtPT57bGV0IGRlc3RpbmF0aW9uO2lmKHIuZGVzdGluYXRpb24pe2Rlc3RpbmF0aW9uPWl0ZW0uYmFzZT9gJHtpdGVtLmJhc2V9JHtkZXN0QmFzZVBhdGh9JHtyLmRlc3RpbmF0aW9ufWA6YCR7ZGVzdEJhc2VQYXRofSR7ci5kZXN0aW5hdGlvbn1gO31uZXdSb3V0ZXMucHVzaCh7Li4ucixkZXN0aW5hdGlvbixzb3VyY2U6YCR7c3JjQmFzZVBhdGh9LyR7aXRlbS5sb2NhbGV9JHtyLnNvdXJjZX1gfSk7fSk7ci5zb3VyY2U9YC86bmV4dEludGVybmFsTG9jYWxlKCR7Y29uZmlnLmkxOG4ubG9jYWxlcy5tYXAobG9jYWxlPT4oMCxfZXNjYXBlU3RyaW5nUmVnZXhwLmRlZmF1bHQpKGxvY2FsZSkpLmpvaW4oJ3wnKX0pJHtyLnNvdXJjZT09PScvJyYmIWNvbmZpZy50cmFpbGluZ1NsYXNoPycnOnIuc291cmNlfWA7aWYoci5kZXN0aW5hdGlvbiYmKF9yJGRlc3RpbmF0aW9uMj1yLmRlc3RpbmF0aW9uKSE9bnVsbCYmX3IkZGVzdGluYXRpb24yLnN0YXJ0c1dpdGgoJy8nKSl7ci5kZXN0aW5hdGlvbj1gLzpuZXh0SW50ZXJuYWxMb2NhbGUke3IuZGVzdGluYXRpb249PT0nLycmJiFjb25maWcudHJhaWxpbmdTbGFzaD8nJzpyLmRlc3RpbmF0aW9ufWA7fX1yLnNvdXJjZT1gJHtzcmNCYXNlUGF0aH0ke3Iuc291cmNlfWA7aWYoci5kZXN0aW5hdGlvbil7ci5kZXN0aW5hdGlvbj1gJHtkZXN0QmFzZVBhdGh9JHtyLmRlc3RpbmF0aW9ufWA7fW5ld1JvdXRlcy5wdXNoKHIpO31yZXR1cm4gbmV3Um91dGVzO31hc3luYyBmdW5jdGlvbiBsb2FkUmVkaXJlY3RzKGNvbmZpZyl7aWYodHlwZW9mIGNvbmZpZy5yZWRpcmVjdHMhPT0nZnVuY3Rpb24nKXtyZXR1cm5bXTt9bGV0IHJlZGlyZWN0cz1hd2FpdCBjb25maWcucmVkaXJlY3RzKCk7Y2hlY2tDdXN0b21Sb3V0ZXMocmVkaXJlY3RzLCdyZWRpcmVjdCcpO3JldHVybiBwcm9jZXNzUm91dGVzKHJlZGlyZWN0cyxjb25maWcsJ3JlZGlyZWN0Jyk7fWFzeW5jIGZ1bmN0aW9uIGxvYWRSZXdyaXRlcyhjb25maWcpe2lmKHR5cGVvZiBjb25maWcucmV3cml0ZXMhPT0nZnVuY3Rpb24nKXtyZXR1cm57YmVmb3JlRmlsZXM6W10sYWZ0ZXJGaWxlczpbXSxmYWxsYmFjazpbXX07fWNvbnN0IF9yZXdyaXRlcz1hd2FpdCBjb25maWcucmV3cml0ZXMoKTtsZXQgYmVmb3JlRmlsZXM9W107bGV0IGFmdGVyRmlsZXM9W107bGV0IGZhbGxiYWNrPVtdO2lmKCFBcnJheS5pc0FycmF5KF9yZXdyaXRlcykmJnR5cGVvZiBfcmV3cml0ZXM9PT0nb2JqZWN0JyYmT2JqZWN0LmtleXMoX3Jld3JpdGVzKS5ldmVyeShrZXk9PmtleT09PSdiZWZvcmVGaWxlcyd8fGtleT09PSdhZnRlckZpbGVzJ3x8a2V5PT09J2ZhbGxiYWNrJykpe2JlZm9yZUZpbGVzPV9yZXdyaXRlcy5iZWZvcmVGaWxlc3x8W107YWZ0ZXJGaWxlcz1fcmV3cml0ZXMuYWZ0ZXJGaWxlc3x8W107ZmFsbGJhY2s9X3Jld3JpdGVzLmZhbGxiYWNrfHxbXTt9ZWxzZXthZnRlckZpbGVzPV9yZXdyaXRlczt9Y2hlY2tDdXN0b21Sb3V0ZXMoYmVmb3JlRmlsZXMsJ3Jld3JpdGUnKTtjaGVja0N1c3RvbVJvdXRlcyhhZnRlckZpbGVzLCdyZXdyaXRlJyk7Y2hlY2tDdXN0b21Sb3V0ZXMoZmFsbGJhY2ssJ3Jld3JpdGUnKTtyZXR1cm57YmVmb3JlRmlsZXM6cHJvY2Vzc1JvdXRlcyhiZWZvcmVGaWxlcyxjb25maWcsJ3Jld3JpdGUnKSxhZnRlckZpbGVzOnByb2Nlc3NSb3V0ZXMoYWZ0ZXJGaWxlcyxjb25maWcsJ3Jld3JpdGUnKSxmYWxsYmFjazpwcm9jZXNzUm91dGVzKGZhbGxiYWNrLGNvbmZpZywncmV3cml0ZScpfTt9YXN5bmMgZnVuY3Rpb24gbG9hZEhlYWRlcnMoY29uZmlnKXtpZih0eXBlb2YgY29uZmlnLmhlYWRlcnMhPT0nZnVuY3Rpb24nKXtyZXR1cm5bXTt9bGV0IGhlYWRlcnM9YXdhaXQgY29uZmlnLmhlYWRlcnMoKTtjaGVja0N1c3RvbVJvdXRlcyhoZWFkZXJzLCdoZWFkZXInKTtyZXR1cm4gcHJvY2Vzc1JvdXRlcyhoZWFkZXJzLGNvbmZpZywnaGVhZGVyJyk7fWFzeW5jIGZ1bmN0aW9uIGxvYWRDdXN0b21Sb3V0ZXMoY29uZmlnKXtjb25zdFtoZWFkZXJzLHJld3JpdGVzLHJlZGlyZWN0c109YXdhaXQgUHJvbWlzZS5hbGwoW2xvYWRIZWFkZXJzKGNvbmZpZyksbG9hZFJld3JpdGVzKGNvbmZpZyksbG9hZFJlZGlyZWN0cyhjb25maWcpXSk7aWYoY29uZmlnLnRyYWlsaW5nU2xhc2gpe3JlZGlyZWN0cy51bnNoaWZ0KHtzb3VyY2U6Jy86ZmlsZSgoPyFcXFxcLndlbGwta25vd24oPzovLiopPykoPzpbXi9dKy8pKlteL10rXFxcXC5cXFxcdyspLycsZGVzdGluYXRpb246Jy86ZmlsZScscGVybWFuZW50OnRydWUsbG9jYWxlOmNvbmZpZy5pMThuP2ZhbHNlOnVuZGVmaW5lZCxpbnRlcm5hbDp0cnVlfSx7c291cmNlOicvOm5vdGZpbGUoKD8hXFxcXC53ZWxsLWtub3duKD86Ly4qKT8pKD86W14vXSsvKSpbXi9cXFxcLl0rKScsZGVzdGluYXRpb246Jy86bm90ZmlsZS8nLHBlcm1hbmVudDp0cnVlLGxvY2FsZTpjb25maWcuaTE4bj9mYWxzZTp1bmRlZmluZWQsaW50ZXJuYWw6dHJ1ZX0pO2lmKGNvbmZpZy5iYXNlUGF0aCl7cmVkaXJlY3RzLnVuc2hpZnQoe3NvdXJjZTpjb25maWcuYmFzZVBhdGgsZGVzdGluYXRpb246Y29uZmlnLmJhc2VQYXRoKycvJyxwZXJtYW5lbnQ6dHJ1ZSxiYXNlUGF0aDpmYWxzZSxsb2NhbGU6Y29uZmlnLmkxOG4/ZmFsc2U6dW5kZWZpbmVkLGludGVybmFsOnRydWV9KTt9fWVsc2V7cmVkaXJlY3RzLnVuc2hpZnQoe3NvdXJjZTonLzpwYXRoKy8nLGRlc3RpbmF0aW9uOicvOnBhdGgrJyxwZXJtYW5lbnQ6dHJ1ZSxsb2NhbGU6Y29uZmlnLmkxOG4/ZmFsc2U6dW5kZWZpbmVkLGludGVybmFsOnRydWV9KTtpZihjb25maWcuYmFzZVBhdGgpe3JlZGlyZWN0cy51bnNoaWZ0KHtzb3VyY2U6Y29uZmlnLmJhc2VQYXRoKycvJyxkZXN0aW5hdGlvbjpjb25maWcuYmFzZVBhdGgscGVybWFuZW50OnRydWUsYmFzZVBhdGg6ZmFsc2UsbG9jYWxlOmNvbmZpZy5pMThuP2ZhbHNlOnVuZGVmaW5lZCxpbnRlcm5hbDp0cnVlfSk7fX1yZXR1cm57aGVhZGVycyxyZXdyaXRlcyxyZWRpcmVjdHN9O31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtY3VzdG9tLXJvdXRlcy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/lib/load-custom-routes.js\n");

/***/ })

};
;